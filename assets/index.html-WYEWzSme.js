import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,o,c as s,d as e,e as a,a as c,f as p}from"./app-xwUbapcG.js";const i={},l={href:"https://spark.apache.org/",target:"_blank",rel:"noopener noreferrer"},_=p('<h2 id="单机-伪分布式-分布式" tabindex="-1"><a class="header-anchor" href="#单机-伪分布式-分布式"><span>单机，伪分布式，分布式</span></a></h2><p>单机：单进程，单节点<br> 伪分布式：多进程，单节点<br> 分布式：多进程，多节点</p><p>单机不是指一台机器，如果10个进程在一台机器上能叫单机吗。这里尤其强调一下，<strong>单节点才可以称之为单机</strong>，单机不用于生产环境的原因是资源太少。Java虚拟机的进程启动后，会申请这台机器上的资源。进程启动后，对应的线程就会去抢占CPU的核。CPU无伤大雅，但是来看内存，Java虚拟机在启动的时候是有对资源的配置的，如果不做任何配置，他启动的资源是比较少的。很明显，一个进程可以做的事情有很多，但是如果不做配置的话，该进程可利用的资源怎么可能多呢？从这个角度来说，单机的性能不够高。</p><p>伪分布式是把多个进程放在一台服务器上使用，这样每个进程就都可以去申请资源。比如每个占据10个G的内存，这样我就能用20个G了。但是一台服务器的上限是固定的，想要启动成百上千个进程是不太可能了，因为这台机器的资源不可能全给你用。多进程可以申请更多的资源，而且抢占CPU的能力更强。能用的资源比单机更多，但是受到单节点的上限，不太可行。伪分布式的好处是在学习时可以看到进程和进程之间的交互</p><p>（抢占CPU能力更强，因为人多力量大，进程中的线程需要CPU来执行，但是抢占CPU是进程干的事，所以进程越多，抢占能力越强。但是现在也没那么准确了，Java中的线程在运行时会转化为操作系统的子进程）</p><p>完全分布式就是多进程多节点了，想咋扩就咋扩。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>分布式不是说每个进程都去处理一样的数据，而是将一个大的数据进行<strong>切分</strong>，然后每个进程去处理一小块</p></div>',7);function d(h,f){const n=r("ExternalLinkIcon");return o(),s("div",null,[e("p",null,[a("官网："),e("a",l,[a("https://spark.apache.org/"),c(n)])]),_])}const g=t(i,[["render",d],["__file","index.html.vue"]]);export{g as default};
