import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as p,d as a,e as n,a as c,f as i}from"./app-faa46583.js";const l={},r=i(`<p>控制反转IoC （Inversion of Control），是一种设计思想，<strong>DI（依赖注入）是实现IOC的一种方法</strong></p><p>没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制</p><p>控制反转后将对象的创建转移给第三方，配置之后，想使用对象直接获取就可以，不需要再创建了</p><p>个人认为所谓控制反转就是，获得依赖对象的方式反转了</p><p>IoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用xml配置，也可以使用注解</p><h2 id="配置文件声明支持注解注册bean" tabindex="-1"><a class="header-anchor" href="#配置文件声明支持注解注册bean" aria-hidden="true">#</a> 配置文件声明<code>支持注解注册bean</code></h2><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>annotation-config</span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了使用上述方法开启全局配置之外，还可以单独声明支持某一个包下的注解</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.mahe666<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="autowired-和-resource" tabindex="-1"><a class="header-anchor" href="#autowired-和-resource" aria-hidden="true">#</a> @Autowired 和 @Resource</h2><p>@Autowired注解是通过bean的类型来进行的注入的</p><p>在复杂情况下如果不能满足使用需求的话，可以使用@Qualifier注解通过bean的名称完成注入</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Autowired</span>
<span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;dog222&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">Dog</span> dog<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@Resource注解本身就能完成上面两个注解的功能，区别在于：@Resource先判断bean名称，再判断bean的类型</p><p>复杂情况下可按照如下方式：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;dog222&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">Dog</span> dog<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="特殊情况" tabindex="-1"><a class="header-anchor" href="#特殊情况" aria-hidden="true">#</a> 特殊情况</h3><p>在实际情况中可能需要根据执行的具体业务来选择bean的情况</p><p>这时可以选择接收所有 <code>具有共同父类</code> 或 <code>实现共同接口</code> 的bean，再根据业务，通过bean名称进行选择</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Autowired</span>
<span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> 基类或接口的名字<span class="token operator">&gt;</span> map<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个map的key就是实现类的名字，然后就可以通过map对象去get类的对象了</p><h2 id="value" tabindex="-1"><a class="header-anchor" href="#value" aria-hidden="true">#</a> @Value</h2><p>给bean的属性注入值，就不需要在xml里面写了</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">&quot;马赫666&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="通过map接收所有实现类" tabindex="-1"><a class="header-anchor" href="#通过map接收所有实现类" aria-hidden="true">#</a> 通过Map接收所有实现类</h2>`,25),d={href:"https://blog.csdn.net/qq_42567801/article/details/124047293",target:"_blank",rel:"noopener noreferrer"};function u(v,m){const s=t("ExternalLinkIcon");return o(),p("div",null,[r,a("p",null,[n("相关博客："),a("a",d,[n("https://blog.csdn.net/qq_42567801/article/details/124047293"),c(s)])])])}const h=e(l,[["render",u],["__file","IOC控制反转.html.vue"]]);export{h as default};
